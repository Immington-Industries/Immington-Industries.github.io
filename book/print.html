<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="wayland_introduction.html">Introduction</a></li><li class="affix"><a href="wlroots_introduction.html">Introduction to wlroots</a></li><li><a href="hello_world.html"><strong aria-hidden="true">1.</strong> Hello World</a></li><li><ol class="section"><li><a href="hello_world_analyze.html"><strong aria-hidden="true">1.1.</strong> Analyzing the code</a></li><li><a href="hello_world_output.html"><strong aria-hidden="true">1.2.</strong> Analyzing the Wayland protocol</a></li><li><a href="hello_world_exercises.html"><strong aria-hidden="true">1.3.</strong> Exercises</a></li></ol></li><li><a href="goodbye_world.html"><strong aria-hidden="true">2.</strong> Goodbye World</a></li><li><ol class="section"><li><a href="goodbye_world_shutdown.html"><strong aria-hidden="true">2.1.</strong> A graceful shutdown</a></li><li><a href="goodbye_world_tty_switching.html"><strong aria-hidden="true">2.2.</strong> TTY switching</a></li><li><a href="goodbye_world_exercises.html"><strong aria-hidden="true">2.3.</strong> Exercises</a></li></ol></li><li><a href="getting_to_the_point.html"><strong aria-hidden="true">3.</strong> Getting to the point</a></li><li><ol class="section"><li><a href="basic_output_cursor.html"><strong aria-hidden="true">3.1.</strong> A basic cursor</a></li><li><a href="wlr_cursor.html"><strong aria-hidden="true">3.2.</strong> A better cursor</a></li><li><a href="getting_to_the_point_exercises.html"><strong aria-hidden="true">3.3.</strong> Exercises</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#how-to-make-a-wayland-compositor-in-rust" id="how-to-make-a-wayland-compositor-in-rust"><h1>How to Make a Wayland Compositor (in Rust)</h1></a>
<a class="header" href="#what-is-wayland" id="what-is-wayland"><h2>What is Wayland?</h2></a>
<p>Wayland is the replacement for the X Window System, colloquially known as X11.</p>
<p>It's recommended that you read <a href="https://wayland.freedesktop.org/">the official Wayland website</a>,
specifically the FAQ, architecture, and documentation, to familiarize yourself with the project.
You should also keep this in your back pocket as you read this book if you need
clarification on any terminology or concepts you don't understand.</p>
<a class="header" href="#what-is-a-wayland-compositor" id="what-is-a-wayland-compositor"><h2>What is a Wayland Compositor?</h2></a>
<p>If you only learn one thing from this book, it should be that:</p>
<p><strong>Wayland is not a compositor</strong></p>
<p><strong>Wayland is not a window manager</strong></p>
<p><strong>Wayland is not a display server</strong></p>
<p>Rather, <strong>Wayland is a <em>protocol</em> for clients and compositors to speak to each other</strong></p>
<p>In a typical X11 system, there are two necessary components: the X
server and the window manager. The X server handles rendering and hardware
interactions, and the window manager handles user interaction and window
arrangement. Almost all X11 desktops use the Xorg server as the X server, and
write their own window managers to provide the design and behavior of their
desktop. Gnome, KDE, i3, and AwesomeWM, for example, have a very different
user experience but are all still based on the Xorg server. Fundamentally, the
window manager is an X11 client like any other, and all X11 clients are able to
interact with your desktop in the same way.</p>
<p>A Wayland compositor is different. It is the sole source of authority
on both rendering/hardware <em>and</em> window management. The right to arrange
windows on screen and drive user interactions is reserved by the compositor.</p>
<p>Here is a list of compositors that will be referenced later in this book:</p>
<ul>
<li><a href="http://way-cooler.org">Way Cooler</a>
<ul>
<li>Written by yours truly, Preston Carpenter. It was the first Wayland compositor written in Rust.</li>
</ul>
</li>
<li><a href="https://github.com/Drakulix/fireplace">Fireplace</a>
<ul>
<li>The second Wayland compositor written in Rust, it's goal is to be written completely in Rust including the Wayland implementation.</li>
</ul>
</li>
<li><a href="https://swaywm.org/">sway</a>
<ul>
<li>A clone of i3 by Drew Devault, the first popular tiling Wayland compositor. The wlroots project is overseen by sway.</li>
</ul>
</li>
<li><a href="https://userbase.kde.org/KWin">KWin</a>
<ul>
<li>The KDE Wayland compositor, is the direct continuation of the X11 Plasma desktop (which is deprecated).</li>
</ul>
</li>
<li><a href="https://gitlab.gnome.org/GNOME/mutter">mutter</a>
<ul>
<li>The Gnome Wayland compositor, is the direct continuation of the X11 Gnome desktop (which is deprecated).</li>
</ul>
</li>
</ul>
<p>These compositors will be mentioned either because I know them well enough to
draw experience and stories from in order to help educate you (such as in Way
Cooler's case), because they are doing something unique (in Fireplace's case) or
because they made meaningful or politically significant decisions that have
impacted the ecosystem (sway, mutter, and KWin).</p>
<a class="header" href="#prerequisites-for-understanding-reading-this-book" id="prerequisites-for-understanding-reading-this-book"><h2>Prerequisites for understanding reading this book</h2></a>
<p>You should know how to program in Rust. You should have the latest stable
version of Rust, any edition.</p>
<p>You should also be able to read C. Even though there will be no C in this book
most of the Wayland ecosystem, including the reference implementation and
wlroots (the framework we will be using), is written in C.</p>
<a class="header" href="#introduction-to-wlroots" id="introduction-to-wlroots"><h1>Introduction to wlroots</h1></a>
<a class="header" href="#what-is-a-compositor-framework" id="what-is-a-compositor-framework"><h2>What is a compositor framework?</h2></a>
<p>Since Wayland is just a protocol, and a compositor has to do all the things the
xserver used to do, a Wayland compositor needs to use more than just Wayland in
order to be functional.</p>
<p>The reason it's in charge of so much is manifold:</p>
<ol>
<li>It means Wayland can be used in a non desktop setup, such on a phone or in an
embedded device where a &quot;cursor&quot; and other such features may not make sense.</li>
<li>By consolidating the jobs into one process it has the potential to be
efficient because there's more information it can use to make a more informed
decision.</li>
<li>Wayland developers are more or less ex-XOrg developers who don't want it to
become big, old, and slow like X11 is. By making libwayland itself simple and
pushing most of the work to the compositors it will more likely survive the
years intact.</li>
</ol>
<p>In order to implement all this additional functionality most compositors use a
few other libraries. The important ones to know are:</p>
<ul>
<li>KMS/DRM (Kernal Mode Settings/ Direct Rendering Manager)
<ul>
<li>Interfaces with GPUs of modern video cards to render to screens.</li>
</ul>
</li>
<li>libinput
<ul>
<li>A library for handling the hardware portions of keyboard, pointers, touch
devices, etc. that make up Wayland seats.</li>
</ul>
</li>
<li>XWayland
<ul>
<li>A compatibility layer that lets users run deprecated X11 apps in Wayland.
This is optional but is generally used by all compositors.</li>
</ul>
</li>
<li>Systemd
<ul>
<li>For handling user sessions. This is also optional but broadly supported
since logind is standard in most Linux distributions.</li>
</ul>
</li>
<li>xkbcommon
<ul>
<li>Handling keyboard descriptions and to process key events.</li>
</ul>
</li>
</ul>
<p>Not all compositors use frameworks, some of them just use Wayland and the other
libraries directly. Mutter and KWin do not use frameworks. Sway and Way Cooler
used to use wlc but they now use wlroots. Fireplace used to use wlc but they now
use Smithay, a framework written completely in Rust.</p>
<a class="header" href="#which-framework-will-this-guide-use" id="which-framework-will-this-guide-use"><h2>Which framework will this guide use?</h2></a>
<p><a href="https://github.com/swaywm/wlroots">wlroots</a> is the compositor framework that
will be used in this book to build a compositor.<sup>1</sup> As of this writing
it is the most mature Wayland compositor framework. There are 3 known other
compositor frameworks, but have various problems:</p>
<ul>
<li><a href="https://github.com/Cloudef/wlc">wlc</a>
<ul>
<li>Deprecated. It was found to abstract too much from the Wayland protocol,
though it was immensely simpler than wlroots. The time measured to get a
working compositor can be measured in hours instead of the expected couple of
days or weeks it will take with wlroots. However even basic use cases, such as
rendering borders around clients, is difficult to do well in wlc. Some use
cases are outright impossible.</li>
</ul>
</li>
<li><a href="https://smithay.github.io/">Smithay</a>
<ul>
<li>A framework written entirely in Rust. Like most things in Rust however it is
unstable and attempting to rewrite the entire stack in Rust.</li>
</ul>
</li>
<li><a href="https://gitlab.freedesktop.org/wayland/weston/tree/master/libweston">libweston</a>
<ul>
<li>A library based on the reference Weston compositor. Essentially you're just
getting a new flavor of Weston instead of your own compositor, which makes it
suffer from the same problems as wlc. As of this writing it's also largely
unused outside of Weston.</li>
</ul>
</li>
</ul>
<p>Here is the elevator pitch for wlroots, taken straight from their README:</p>
<blockquote>
<p>Pluggable, composable, unopinionated modules for building a Wayland
compositor; or about 50,000 lines of code you were going to write anyway.</p>
<ul>
<li>wlroots provides backends that abstract the underlying display and input
hardware, including KMS/DRM, libinput, Wayland, X11, and headless backends,
plus any custom backends you choose to write, which can all be created or
destroyed at runtime and used in concert with each other.</li>
<li>wlroots provides unopinionated, mostly standalone implementations of many
Wayland interfaces, both from wayland.xml and various protocol extensions.
We also promote the standardization of portable extensions across many
compositors.</li>
<li>wlroots provides several powerful, standalone, and optional tools that
implement components common to many compositors, such as the arrangement of
outputs in physical space.</li>
<li>wlroots provides an Xwayland abstraction that allows you to have excellent
Xwayland support without worrying about writing your own X11 window manager
on top of writing your compositor.</li>
<li>wlroots provides a renderer abstraction that simple compositors can use to
avoid writing GL code directly, but which steps out of the way when your needs
demand custom rendering code.</li>
</ul>
</blockquote>
<hr />
<p><sup>1</sup> It is written in C, but there are <a href="https://github.com/swaywm/wlroots-rs">safe Rust bindings</a> written by me which is what will be used. The only thing the Rust library adds is memory safety and some more structure to the library. All the real features are implemented in wlroots.</p>
<a class="header" href="#hello-world" id="hello-world"><h1>Hello World</h1></a>
<p>Each chapter's code contents will have its own folder with a name prefixed by the chapter
number. For example, this chapter's code is stored in <code>1-hello-world/</code>. The code
can be found <a href="https://github.com/swaywm/wlroots-rs/tree/book/how-to-make-a-wayland-compositor/src/">here</a>.</p>
<p>The only dependency used, apart from the standard library, will be wlroots. A
more useful compositor will want to use other libraries, but it is not done here
in order to avoid choosing favorites while also being self contained and complete.</p>
<blockquote>
<p>An important note to copy pasters: This document as well as the example code base
is under the CC0 license.</p>
<p>So copy and paste liberally, you can use this code as a jumping off point.</p>
<p><strong>This does <em>not</em> apply to wlroots-rs or wlroots, both of which are under
the MIT license.</strong></p>
</blockquote>
<a class="header" href="#boring-setup" id="boring-setup"><h2>Boring setup</h2></a>
<p>wlroots-rs is in crates.io. If you want to install it, simply add this to your
Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
wlroots = {version = &quot;0.2&quot;, features = [&quot;unstable&quot;, &quot;static&quot;]}
</code></pre>
<p>The <code>&quot;unstable&quot;</code> feature flag enables the wlroots features whose API hasn't
stabilized yet. For now, this is necessary to build a compositor. In the future
this restriction will be gradually lifted as the library matures.</p>
<p>The <code>&quot;static&quot;</code> feature flag statically links the wlroots library to the binary.
This is optional, but encouraged since there's no stable ABI guarantee and it
makes it easier to distribute the compositor to others.</p>
<p>Because the library is changing constantly however, it is suggested you add it
as a git submodule to your project instead of using crates.io.</p>
<a class="header" href="#a-minimal-compositor" id="a-minimal-compositor"><h2>A minimal compositor</h2></a>
<p>Here is the smallest, simplest compositor you can make with wlroots:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate wlroots;

use wlroots::{compositor, utils::log::{WLR_DEBUG, init_logging}};

fn main() {
    init_logging(WLR_DEBUG, None);
    compositor::Builder::new().build_auto(()).run()
}
</code></pre></pre>
<p>This compositor is useless. In fact, it's dangerously useless. However it's also
very instructive considering how short it is.</p>
<p>You can compile and run<sup>1</sup> the above in any existing X11 window manager
or Wayland compositor and it will run in a nested window.<sup>2</sup> However if
you run it in a separate TTY it will use the DRM backend. This is usually the
backend that will be used when you're not testing the compositor. If you run
this code on DRM, you can't escape the compositor. If you do this you will need
to reboot to escape.</p>
<p>Because no callbacks were set up for the events the compositor will just keep
running forever doing nothing. You can't even switch TTYs because that's a
feature that the compositor needs to implement itself.</p>
<p>This example is a little silly, but it highlights just how much needs to be
implemented -- our compositor can't even shut itself off.</p>
<hr />
<p><sup>1</sup> If you are running on a system with systemd and have the feature
enabled (it is by default) it should &quot;just work&quot;. If not, you'll need set the
setuid bit on the binary with <code>chmod u+s</code>.</p>
<p><sup>2</sup> This is a wlroots feature that is built into the <code>build_auto</code>
function. It is very useful for debugging.</p>
<a class="header" href="#analyzing-the-code" id="analyzing-the-code"><h1>Analyzing the code</h1></a>
<p>After explaining what each change gives us, I'll then explain what each line of code does.</p>
<p>At the end of each chapter there will be a list of suggestions and challenges
which I suggest you at least read over if not try. They exist to encourage you
to read through the <a href="http://way-cooler.org/docs/wlroots/index.html">wlroots-rs
documentation</a> and <a href="https://wayland.freedesktop.org/docs/html/">Wayland
documentation</a> in order to better
familiarize yourself.</p>
<a class="header" href="#logging-setup" id="logging-setup"><h2>Logging setup</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    init_logging(WLR_DEBUG, None);
#}</code></pre></pre>
<p>This line is not strictly necessary for the compositor to run. wlroots (and
wlroots-rs) prints a log message each time something interesting happens which
is useful for debugging. In general, you should always have this line in your
compositor.</p>
<p>The first parameter is the minimum level that is logged. The second parameter is
an optional callback that will be called each time a message is logged.</p>
<p>You can log a message using this system by using the <code>wlr_log!</code>
macro<sup>1</sup>. Here is an example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// It has the same syntax as println! or format!
wlr_log!(WLR_DEBUG, &quot;This is an example {:?}&quot;, some_struct)
#}</code></pre></pre>
<p>The first parameter is the log level you want to log at. Any arguments after
that are passed to <code>format!</code> with the format string being the second argument.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    compositor::Builder::new().build_auto(()).run()
#}</code></pre></pre>
<p>This is the real meat of the program.</p>
<p>This creates a builder for a <code>Compositor</code>. There can only be one <code>Compositor</code>
object per process<sup>2</sup> . The builder is how Wayland globals and their
callbacks are set up.</p>
<p>In this case no callbacks are set up the <code>Compositor</code> is just immediately built.
When you build the compositor, just like you build any object in wlroots-rs, you
need to give it user state. In this case, there is no state to store so you can
just pass the unit type <code>()</code>.</p>
<p>Once the <code>Compositor</code> is set up then <code>run</code> can be called. This will put it in
the main Wayland event loop listening for events and dispatching to the
callbacks. It will keep running until <code>wlroots::terminate</code> is called. Since thi s
is never call it in this compositor it won't happen until it's kill it via a
signal.</p>
<hr />
<p><sup>1</sup> Don't forget to import macros by prepending <code>#[macro_use]</code> to
<code>extern crate wlroots</code>.</p>
<p><sup>2</sup> wlroots-rs is not designed to be thread safe with its objects. Most
objects are <code>!Send</code> and <code>!Sync</code>.</p>
<a class="header" href="#analyzing-the-wayland-protocol" id="analyzing-the-wayland-protocol"><h1>Analyzing the Wayland protocol</h1></a>
<p>This is the log output from our compositor when it's ran as a nested Wayland instance:</p>
<pre><code>[wlroots-sys/wlroots/backend/wayland/backend.c:186] Creating wayland backend
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_data_device_manager v3
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_shm v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_linux_dmabuf_v1 v3
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_drm v2
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zxdg_output_manager_v1 v2
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_compositor v4
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_subcompositor v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zxdg_shell_v6 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: xdg_wm_base v2
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_shell v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_layer_shell_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_tablet_manager_v2 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: gamma_control_manager v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_gamma_control_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: orbital_screenshooter v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_export_dmabuf_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: org_kde_kwin_server_decoration_manager v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: gtk_primary_selection_device_manager v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: org_kde_kwin_idle v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_idle_inhibit_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_input_inhibit_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_input_method_manager_v2 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_text_input_manager_v3 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_virtual_keyboard_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_screencopy_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zxdg_decoration_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_pointer_constraints_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wp_presentation v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_output v3
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_seat v6
[wlroots-sys/wlroots/backend/wayland/wl_seat.c:398] seat 0x7fb3a2235e10 offered pointer
[wlroots-sys/wlroots/backend/wayland/wl_seat.c:411] seat 0x7fb3a2235e10 offered keyboard
[wlroots-sys/wlroots/render/egl.c:149] Using EGL 1.4
[wlroots-sys/wlroots/render/egl.c:150] Supported EGL extensions: EGL_ANDROID_blob_cache EGL_ANDROID_native_fence_sync EGL_EXT_buffer_age EGL_EXT_create_context_robustness EGL_EXT_image_dma_buf_import EGL_EXT_image_dma_buf_import_modifiers EGL_EXT_swap_buffers_with_damage EGL_IMG_context_priority EGL_KHR_config_attribs EGL_KHR_create_context EGL_KHR_create_context_no_error EGL_KHR_fence_sync EGL_KHR_get_all_proc_addresses EGL_KHR_gl_colorspace EGL_KHR_gl_renderbuffer_image EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_3D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_image_base EGL_KHR_no_config_context EGL_KHR_reusable_sync EGL_KHR_surfaceless_context EGL_KHR_swap_buffers_with_damage EGL_EXT_pixel_format_float EGL_KHR_wait_sync EGL_MESA_configless_context EGL_MESA_drm_image EGL_MESA_image_dma_buf_export EGL_WL_bind_wayland_display EGL_WL_create_wayland_buffer_from_image 
[wlroots-sys/wlroots/render/egl.c:151] EGL vendor: Mesa Project
[wlroots-sys/wlroots/render/egl.c:97] Supported dmabuf buffer formats: AR30 XR30 AB30 XB30 AR24 AB24 XR24 XB24 AR15 RG16 R8   R16  GR88 GR32 YUV9 YU11 YU12 YU16 YU24 YVU9 YV11 YV12 YV16 YV24 NV12 NV16 YUYV UYVY 
[wlroots-sys/wlroots/render/gles2/renderer.c:553] Using OpenGL ES 3.2 Mesa 18.3.1
[wlroots-sys/wlroots/render/gles2/renderer.c:554] GL vendor: Intel Open Source Technology Center
[wlroots-sys/wlroots/render/gles2/renderer.c:555] Supported GLES2 extensions: GL_EXT_blend_minmax GL_EXT_multi_draw_arrays GL_EXT_texture_filter_anisotropic GL_EXT_texture_compression_s3tc GL_EXT_occlusion_query_boolean GL_EXT_texture_compression_dxt1 GL_EXT_texture_format_BGRA8888 GL_OES_compressed_ETC1_RGB8_texture GL_OES_depth24 GL_OES_element_index_uint GL_OES_fbo_render_mipmap GL_OES_mapbuffer GL_OES_rgb8_rgba8 GL_OES_standard_derivatives GL_OES_stencil8 GL_OES_texture_3D GL_OES_texture_float GL_OES_texture_float_linear GL_OES_texture_half_float GL_OES_texture_half_float_linear GL_OES_texture_npot GL_OES_vertex_half_float GL_EXT_texture_sRGB_decode GL_OES_EGL_image GL_OES_depth_texture GL_OES_packed_depth_stencil GL_EXT_texture_type_2_10_10_10_REV GL_OES_get_program_binary GL_APPLE_texture_max_level GL_EXT_discard_framebuffer GL_EXT_read_format_bgra GL_EXT_frag_depth GL_NV_fbo_color_attachments GL_OES_EGL_image_external GL_OES_EGL_sync GL_OES_vertex_array_object GL_OES_viewport_array GL_ANGLE_texture_compression_dxt3 GL_ANGLE_texture_compression_dxt5 GL_EXT_robustness GL_EXT_texture_rg GL_EXT_unpack_subimage GL_NV_draw_buffers GL_NV_read_buffer GL_NV_read_depth GL_NV_read_depth_stencil GL_NV_read_stencil GL_EXT_draw_buffers GL_EXT_map_buffer_range GL_KHR_debug GL_KHR_robustness GL_KHR_texture_compression_astc_ldr GL_OES_depth_texture_cube_map GL_OES_required_internalformat GL_OES_surfaceless_context GL_EXT_color_buffer_float GL_EXT_separate_shader_objects GL_EXT_shader_framebuffer_fetch GL_EXT_shader_integer_mix GL_EXT_tessellation_point_size GL_EXT_tessellation_shader GL_INTEL_conservative_rasterization GL_INTEL_performance_query GL_ANDROID_extension_pack_es31a GL_EXT_base_instance GL_EXT_compressed_ETC1_RGB8_sub_texture GL_EXT_copy_image GL_EXT_draw_buffers_indexed GL_EXT_draw_elements_base_vertex GL_EXT_gpu_shader5 GL_EXT_polygon_offset_clamp GL_EXT_primitive_bounding_box GL_EXT_render_snorm GL_EXT_shader_io_blocks GL_EXT_texture_border_clamp GL_EXT_texture_buffer GL_EXT_texture_cube_map_array GL_EXT_texture_norm16 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_KHR_context_flush_control GL_KHR_robust_buffer_access_behavior GL_NV_image_formats GL_OES_copy_image GL_OES_draw_buffers_indexed GL_OES_draw_elements_base_vertex GL_OES_gpu_shader5 GL_OES_primitive_bounding_box GL_OES_sample_shading GL_OES_sample_variables GL_OES_shader_io_blocks GL_OES_shader_multisample_interpolation GL_OES_tessellation_point_size GL_OES_tessellation_shader GL_OES_texture_border_clamp GL_OES_texture_buffer GL_OES_texture_cube_map_array GL_OES_texture_stencil8 GL_OES_texture_storage_multisample_2d_array GL_OES_texture_view GL_EXT_blend_func_extended GL_EXT_buffer_storage GL_EXT_geometry_point_size GL_EXT_geometry_shader GL_EXT_shader_samples_identical GL_KHR_no_error GL_KHR_texture_compression_astc_sliced_3d GL_NV_fragment_shader_interlock GL_OES_EGL_image_external_essl3 GL_OES_geometry_point_size GL_OES_geometry_shader GL_OES_shader_image_atomic GL_EXT_clip_cull_distance GL_EXT_disjoint_timer_query GL_MESA_shader_integer_functions GL_EXT_shader_framebuffer_fetch_non_coherent GL_MESA_framebuffer_flip_y 
[src/compositor.rs:434] Running compositor on wayland display wayland-2
[src/compositor.rs:497] Starting compositor
[wlroots-sys/wlroots/backend/wayland/backend.c:104] Initializating wayland backend
[GLES2] FS SIMD8 shader: 5 inst, 0 loops, 24 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 80 to 48 bytes.
[GLES2] FS SIMD16 shader: 5 inst, 0 loops, 34 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 80 to 48 bytes.
[GLES2] VS SIMD8 shader: 28 inst, 0 loops, 116 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 448 to 336 bytes.
[GLES2] FS SIMD16 shader: 2 inst, 0 loops, 0 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 32 to 32 bytes.
 
</code></pre>
<p>Your output will probably not match exactly, but it should roughly have this output.</p>
<a class="header" href="#backend-setup" id="backend-setup"><h2>Backend Setup</h2></a>
<p>When <code>build_auto</code> is called on <code>Compositor</code> it will dynamically detect which
backend makes the most sense to spin up. If the compositor is ran in X11 or a
Wayland compositor then it will run as a client with all the contents rendered
to  a window. If ran on a TTY then it uses the kernel's DRM module. It also
possible to <a href="http://way-cooler.org/docs/wlroots/compositor/struct.Builder.html#method.build_x11">specify a backend directly</a>.</p>
<pre><code>[wlroots-sys/wlroots/backend/wayland/backend.c:186] Creating wayland backend
</code></pre>
<p>This first line shows which backend was selected. The Wayland backend was
selected here, because it was ran in another Wayland instance.<sup>1</sup></p>
<a class="header" href="#wayland-globals" id="wayland-globals"><h2>Wayland globals</h2></a>
<pre><code>[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_data_device_manager v3
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_shm v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_linux_dmabuf_v1 v3
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_drm v2
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zxdg_output_manager_v1 v2
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_compositor v4
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_subcompositor v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zxdg_shell_v6 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: xdg_wm_base v2
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_shell v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_layer_shell_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_tablet_manager_v2 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: gamma_control_manager v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_gamma_control_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: orbital_screenshooter v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_export_dmabuf_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: org_kde_kwin_server_decoration_manager v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: gtk_primary_selection_device_manager v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: org_kde_kwin_idle v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_idle_inhibit_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_input_inhibit_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_input_method_manager_v2 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_text_input_manager_v3 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_virtual_keyboard_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwlr_screencopy_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zxdg_decoration_manager_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: zwp_pointer_constraints_v1 v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wp_presentation v1
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_output v3
[wlroots-sys/wlroots/backend/wayland/backend.c:65] Remote wayland global: wl_seat v6
</code></pre>
<p>This is a list of all the globals that the parent compositor was advertising.
This is output is specific to the Wayland backend. Protocols that are unstable
have their names prepended with <code>z</code> by convention.</p>
<p>Our compositor also exposes some globals even in this minimal state. Globals are
the way clients can start up communication with the Wayland compositor. There
are some default ones that come bundled with Wayland, such as <code>wl_compositor</code>,
and then there are custom ones defined on a per compositor basis. wlroots comes
with some popular custom protocols already implemented, but you have to
explicitly opt in to using them explicitly in the builder. <a href="http://way-cooler.org/docs/wlroots/compositor/struct.Builder.html#method.xdg_shell_manager">xdg shell, for
example, is an optional protocol that wasn't used in this example</a>.</p>
<p>In order to see what globals the toy compositor is advertising you need to use a
useful Wayland utility called <code>weston-info</code>.<sup>2</sup> It lists the Wayland
globals advertised by the current compositor. The current compositor is
determined by looking at the <code>$WAYLAND_DISPLAY</code> environment variable similar to
how in X the current xserver is determined with <code>$DISPLAY</code>.</p>
<p>In the log output it prints out the <code>$WAYLAND_DISPLAY</code>:</p>
<pre><code>[src/compositor.rs:434] Running compositor on wayland display wayland-2
</code></pre>
<p>Lets see what globals are being advertised by our compositor:</p>
<pre><code>interface: 'wl_compositor', version: 4, name: 1
interface: 'wl_subcompositor', version: 1, name: 2
</code></pre>
<p><code>weston-info</code> prints out the name of each exposed interface on a new line along
with the highest advertised interface version and the relative, atomically
increasing index (confusingly prepended with &quot;name&quot;).</p>
<p><code>wl_compositor</code> and <code>wl_subcompositor</code> are both standard Wayland interfaces.
<code>wl_subcompositor</code> is automatically started by wlroots when a <code>wl_compositor</code> is
used. A <code>wl_compositor</code> is the base global that all clients depend on. From this
global a client can create a <code>wl_surface</code> and a <code>wl_region</code>.</p>
<p>A <code>wl_surface</code> is a basic building block for drawing and rendering contents to
the screen in Wayland. A client needs more than a <code>wl_surface</code> in order to
render to the screen, but that is the basic object a compositor needs in order
to render.<sup>3</sup></p>
<p>A <code>wl_region</code> is the object that allows clients to tell the compositor where, in
surface level coordinates<sup>4</sup>, it wants to handle input and where it is
rendering content. Where it wants input is very important, but the default is
that it accepts input everywhere in the surface. Specifying an area where the
client is rendering content is important because it allows the compositor to
know that any content behind that doesn't need to be redrawn. As a very simple
example of this if there is a moving background on the screen and there is a
fullscreen window then there is no need to draw the background saving precious
cycles.</p>
<p>The ability to specify only parts of the screen to update is a major feature of
Wayland which will be totally ignored until a much later chapter. When starting
out it's simple enough to simply redraw the entire screen each time a new frame
is available. For non-toy compositors though it is vital that proper damage
tracking (as the feature is called) is implemented. It reduces power consumption
and makes the compositor faster.</p>
<a class="header" href="#seat-offerings" id="seat-offerings"><h2>Seat offerings</h2></a>
<pre><code>[wlroots-sys/wlroots/backend/wayland/wl_seat.c:398] seat 0x7fb3a2235e10 offered pointer
[wlroots-sys/wlroots/backend/wayland/wl_seat.c:411] seat 0x7fb3a2235e10 offered keyboard
</code></pre>
<p>Rootson automatically offers the keyboard and mouse to all new windows that appear. This allows input to passthrough directly to the toy compositor, but it also hints at this concept of Wayland &quot;seats&quot;.</p>
<p><a href="https://wayland.freedesktop.org/docs/html/apa.html#protocol-spec-wl_seat">A Wayland seat is a collection of inputs devices</a> usually handled under the hood by libinput. Seats are created by the compositor, advertised to any new clients including when new input methods are added, and are used to facilitate user input to clients including drag-in-drop.</p>
<p>Seats are necessary to communicate properly with clients and will be explored in a later chapter.</p>
<a class="header" href="#egl-setup" id="egl-setup"><h2>EGL Setup</h2></a>
<pre><code>[wlroots-sys/wlroots/render/egl.c:149] Using EGL 1.4
[wlroots-sys/wlroots/render/egl.c:150] Supported EGL extensions: EGL_ANDROID_blob_cache EGL_ANDROID_native_fence_sync EGL_EXT_buffer_age EGL_EXT_create_context_robustness EGL_EXT_image_dma_buf_import EGL_EXT_image_dma_buf_import_modifiers EGL_EXT_swap_buffers_with_damage EGL_IMG_context_priority EGL_KHR_config_attribs EGL_KHR_create_context EGL_KHR_create_context_no_error EGL_KHR_fence_sync EGL_KHR_get_all_proc_addresses EGL_KHR_gl_colorspace EGL_KHR_gl_renderbuffer_image EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_3D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_image_base EGL_KHR_no_config_context EGL_KHR_reusable_sync EGL_KHR_surfaceless_context EGL_KHR_swap_buffers_with_damage EGL_EXT_pixel_format_float EGL_KHR_wait_sync EGL_MESA_configless_context EGL_MESA_drm_image EGL_MESA_image_dma_buf_export EGL_WL_bind_wayland_display EGL_WL_create_wayland_buffer_from_image 
[wlroots-sys/wlroots/render/egl.c:151] EGL vendor: Mesa Project
[wlroots-sys/wlroots/render/egl.c:97] Supported dmabuf buffer formats: AR30 XR30 AB30 XB30 AR24 AB24 XR24 XB24 AR15 RG16 R8   R16  GR88 GR32 YUV9 YU11 YU12 YU16 YU24 YVU9 YV11 YV12 YV16 YV24 NV12 NV16 YUYV UYVY 
[wlroots-sys/wlroots/render/gles2/renderer.c:553] Using OpenGL ES 3.2 Mesa 18.3.1
[wlroots-sys/wlroots/render/gles2/renderer.c:554] GL vendor: Intel Open Source Technology Center
[wlroots-sys/wlroots/render/gles2/renderer.c:555] Supported GLES2 extensions: GL_EXT_blend_minmax GL_EXT_multi_draw_arrays GL_EXT_texture_filter_anisotropic GL_EXT_texture_compression_s3tc GL_EXT_occlusion_query_boolean GL_EXT_texture_compression_dxt1 GL_EXT_texture_format_BGRA8888 GL_OES_compressed_ETC1_RGB8_texture GL_OES_depth24 GL_OES_element_index_uint GL_OES_fbo_render_mipmap GL_OES_mapbuffer GL_OES_rgb8_rgba8 GL_OES_standard_derivatives GL_OES_stencil8 GL_OES_texture_3D GL_OES_texture_float GL_OES_texture_float_linear GL_OES_texture_half_float GL_OES_texture_half_float_linear GL_OES_texture_npot GL_OES_vertex_half_float GL_EXT_texture_sRGB_decode GL_OES_EGL_image GL_OES_depth_texture GL_OES_packed_depth_stencil GL_EXT_texture_type_2_10_10_10_REV GL_OES_get_program_binary GL_APPLE_texture_max_level GL_EXT_discard_framebuffer GL_EXT_read_format_bgra GL_EXT_frag_depth GL_NV_fbo_color_attachments GL_OES_EGL_image_external GL_OES_EGL_sync GL_OES_vertex_array_object GL_OES_viewport_array GL_ANGLE_texture_compression_dxt3 GL_ANGLE_texture_compression_dxt5 GL_EXT_robustness GL_EXT_texture_rg GL_EXT_unpack_subimage GL_NV_draw_buffers GL_NV_read_buffer GL_NV_read_depth GL_NV_read_depth_stencil GL_NV_read_stencil GL_EXT_draw_buffers GL_EXT_map_buffer_range GL_KHR_debug GL_KHR_robustness GL_KHR_texture_compression_astc_ldr GL_OES_depth_texture_cube_map GL_OES_required_internalformat GL_OES_surfaceless_context GL_EXT_color_buffer_float GL_EXT_separate_shader_objects GL_EXT_shader_framebuffer_fetch GL_EXT_shader_integer_mix GL_EXT_tessellation_point_size GL_EXT_tessellation_shader GL_INTEL_conservative_rasterization GL_INTEL_performance_query GL_ANDROID_extension_pack_es31a GL_EXT_base_instance GL_EXT_compressed_ETC1_RGB8_sub_texture GL_EXT_copy_image GL_EXT_draw_buffers_indexed GL_EXT_draw_elements_base_vertex GL_EXT_gpu_shader5 GL_EXT_polygon_offset_clamp GL_EXT_primitive_bounding_box GL_EXT_render_snorm GL_EXT_shader_io_blocks GL_EXT_texture_border_clamp GL_EXT_texture_buffer GL_EXT_texture_cube_map_array GL_EXT_texture_norm16 GL_KHR_blend_equation_advanced GL_KHR_blend_equation_advanced_coherent GL_KHR_context_flush_control GL_KHR_robust_buffer_access_behavior GL_NV_image_formats GL_OES_copy_image GL_OES_draw_buffers_indexed GL_OES_draw_elements_base_vertex GL_OES_gpu_shader5 GL_OES_primitive_bounding_box GL_OES_sample_shading GL_OES_sample_variables GL_OES_shader_io_blocks GL_OES_shader_multisample_interpolation GL_OES_tessellation_point_size GL_OES_tessellation_shader GL_OES_texture_border_clamp GL_OES_texture_buffer GL_OES_texture_cube_map_array GL_OES_texture_stencil8 GL_OES_texture_storage_multisample_2d_array GL_OES_texture_view GL_EXT_blend_func_extended GL_EXT_buffer_storage GL_EXT_geometry_point_size GL_EXT_geometry_shader GL_EXT_shader_samples_identical GL_KHR_no_error GL_KHR_texture_compression_astc_sliced_3d GL_NV_fragment_shader_interlock GL_OES_EGL_image_external_essl3 GL_OES_geometry_point_size GL_OES_geometry_shader GL_OES_shader_image_atomic GL_EXT_clip_cull_distance GL_EXT_disjoint_timer_query GL_MESA_shader_integer_functions GL_EXT_shader_framebuffer_fetch_non_coherent GL_MESA_framebuffer_flip_y 
...
[GLES2] FS SIMD8 shader: 5 inst, 0 loops, 24 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 80 to 48 bytes.
[GLES2] FS SIMD16 shader: 5 inst, 0 loops, 34 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 80 to 48 bytes.
[GLES2] VS SIMD8 shader: 28 inst, 0 loops, 116 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 448 to 336 bytes.
[GLES2] FS SIMD16 shader: 2 inst, 0 loops, 0 cycles, 0:0 spills:fills, Promoted 0 constants, compacted 32 to 32 bytes.
</code></pre>
<p>Currently all backends need a renderer in wlroots which is automatically setup when you create one. This output is from the Wayland backend setting up the EGL drawing for rendering. In the future this may change, as the rendering API <a href="https://github.com/swaywm/wlroots/issues/774">is</a> <a href="https://github.com/swaywm/wlroots/issues/558">in</a> <a href="https://github.com/swaywm/wlroots/issues/1352">flux</a>.</p>
<a class="header" href="#everything-after-run-is-called" id="everything-after-run-is-called"><h2>Everything after run is called</h2></a>
<pre><code>[src/compositor.rs:434] Running compositor on wayland display wayland-2
[src/compositor.rs:497] Starting compositor
[wlroots-sys/wlroots/backend/wayland/backend.c:104] Initializating wayland backend
</code></pre>
<p>Everything after these lines, including these lines, is printed to the log after <code>run</code> is called. Since there are no clients that connected there is no logging from them and since there are no event handlers nothing else happens.</p>
<hr />
<p><sup>1</sup> On my machine it was ran in rootson, the wlroots reference compositor, which is why Wayland was selected.</p>
<p><sup>2</sup> In most Linux distributions this utility is packaged along with weston, the reference Wayland compositor.</p>
<p><sup>3</sup> Usually a surface is wrapped in a shell. What a shell adds to a <code>wl_surface</code> is <em>context</em>. Without the proper context a compositor doesn't know if the surface it was just handed by the client is a standalone window, a popup, a background, a status bar, or a cursor to be rendered. All of them need to be handled differently and they are all handled using a dedicated wayland &quot;shell&quot; or a specialized non-shell protocol.</p>
<p><sup>4</sup> It has to be surface level because clients doesn't know about anything but the content it renders.</p>
<a class="header" href="#exercises" id="exercises"><h1>Exercises</h1></a>
<a class="header" href="#russian-doll-compositor" id="russian-doll-compositor"><h2>Russian Doll Compositor</h2></a>
<p>You can trick a Wayland compositor to run as the child of a compositor you're
not currently in by overriding the <code>WAYLAND_DISPLAY</code> variable.</p>
<p>Using this, get the toy compositor to run inside the toy compositor.</p>
<a class="header" href="#reimplement-build_auto" id="reimplement-build_auto"><h2>Reimplement build_auto</h2></a>
<p><a href="http://way-cooler.org/docs/wlroots/compositor/struct.Builder.html">Explore some of the options for the
<code>compositor::Builder</code></a>.</p>
<p>Reimplement <code>build_auto</code> using the explicit build functions.</p>
<p>Use <code>$DISPLAY</code> to detect when running nested in X11 and <code>$WAYLAND_DISPLAY</code> to
detect running nested in Wayland.</p>
<a class="header" href="#goodbye-world" id="goodbye-world"><h1>Goodbye World</h1></a>
<p>The compositor from the previous section has a bug: it can't be exited from if
it is started in DRM. This is a pretty serious bug, one that will be addressed
in two ways in this section.</p>
<a class="header" href="#gracefully-shutting-down" id="gracefully-shutting-down"><h3>Gracefully shutting Down</h3></a>
<p>The first is the most extreme, and easiest to implement, option: adding a shut
down key sequence. The compositor will be configured so if the user presses
<code>Ctrl+Shift+Escape</code> it will gracefully terminate with a zero exit status. This
will be useful in debugging the compositor as it makes it easy to shut down even
in DRM.<sup>1</sup></p>
<a class="header" href="#tty-switching" id="tty-switching"><h3>TTY switching</h3></a>
<p>The second escape access is a feature that is often taken for granted: the
ability to switch TTYs. The standard <code>Ctrl+Alt+F#</code> sequence will be implemented
to switch TTYs when the compositor is running on DRM. When it's running on
another backend it will simply ignore that (since it won't have the proper
access controls to do the context switch).</p>
<a class="header" href="#what-youll-learn" id="what-youll-learn"><h2>What you'll learn</h2></a>
<p>This chapter will primarily concern itself with <a href="http://way-cooler.org/docs/wlroots/input/keyboard/trait.Handler.html">setting up
handlers</a>
for the first time, handling <a href="http://way-cooler.org/docs/wlroots/input/keyboard/event/struct.Key.html">keyboard
input</a>,
and <a href="http://way-cooler.org/docs/wlroots/utils/struct.Handle.html">learning to use wlroots-rs handles</a>.</p>
<a class="header" href="#a-graceful-shutdown" id="a-graceful-shutdown"><h1>A graceful shutdown</h1></a>
<p>Before the compositor can begin listening for keyboard input it needs to listen
for keyboards.</p>
<p>For each resource type that can be created there is a manager module that
provides a builder and some function signatures for the compositor writer to
describe how a resource should be managed.
<a href="http://way-cooler.org/docs/wlroots/input/manager/index.html">Here is the input device resource manager module</a>.</p>
<p>To specify that a keyboard should be managed by the compositor a function needs
to be defined <a href="http://way-cooler.org/docs/wlroots/input/manager/type.KeyboardAdded.html">matching the keyboard resource manager
signature</a>.
This function will be later called by wlroots when a keyboard is announced to
the compositor through libinput.</p>
<p>Once the function is defined with the necessary signature it needs to be
<a href="http://way-cooler.org/docs/wlroots/input/manager/struct.Builder.html">put into the resource builder</a>
and the resource builder <a href="http://way-cooler.org/docs/wlroots/compositor/struct.Builder.html#method.input_manager">passed to the
<code>compositor::Builder</code></a>.</p>
<a class="header" href="#a-minimal-keyboard-handler" id="a-minimal-keyboard-handler"><h2>A Minimal Keyboard Handler</h2></a>
<p>This is the simplest function that implements the signature:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn keyboard_added(_compositor_handle: compositor::Handle,
                  _keyboard_handle: keyboard::Handle)
                  -&gt; Option&lt;Box&lt;keyboard::Handler&gt;&gt; {
    None
}
#}</code></pre></pre>
<p>This is how it's passed to the builder:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    init_logging(WLR_DEBUG, None);
    let input_builder = input::manager::Builder::default()
        .keyboard_added(keyboard_added);
    compositor::Builder::new()
        .input_manager(input_builder)
        .build_auto(())
        .run()
}
</code></pre></pre>
<p>With the provided implementation whenever a keyboard is announced wlroots-rs
will call <code>keyboard_added</code>. Since the function unconditionally returns <code>None</code> a
keyboard resource handler will never be allocated and the resource will be dropped.</p>
<a class="header" href="#holding-on-to-the-resource" id="holding-on-to-the-resource"><h2>Holding on to the resource</h2></a>
<p>In order to hang on to the resource a handler must be defined and allocated
using <code>Box</code> to make a trait object. The handler defines how to deal with event
the resource can trigger, including <a href="http://way-cooler.org/docs/wlroots/input/keyboard/trait.Handler.html#method.on_key">when a key is
pressed</a>.</p>
<p>Since a resource handler is a trait object each resource handler has a piece of
state it holds between callbacks separate from the other resources. It is here
where the &quot;shift&quot; and &quot;ctrl&quot; pressed state will be held:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Default)]
struct KeyboardHandler {
    shift_pressed: bool,
    ctrl_pressed: bool
}
#}</code></pre></pre>
<p>In order to be able to return a <code>Box</code>-ed version of this struct in
the <code>keyboard_added</code> function <code>keyboard::Handler</code> will need to be implemented:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn keyboard_added(_compositor_handle: compositor::Handle,
                  _keyboard_handle: keyboard::Handle)
                  -&gt; Option&lt;Box&lt;keyboard::Handler&gt;&gt; {
    Some(Box::new(KeyboardHandler::default()))
}

impl keyboard::Handler for KeyboardHandler {
    // All handler methods have a default implementation that does nothing.
    // So because no methods are define here, every event on the keyboard
    // is ignored.
}
#}</code></pre></pre>
<a class="header" href="#listening-for-keyboard-modifiers" id="listening-for-keyboard-modifiers"><h2>Listening for keyboard modifiers</h2></a>
<p>When a key is pressed <a href="http://way-cooler.org/docs/wlroots/input/keyboard/trait.Handler.html#method.on_key">this
method</a>
receives <a href="http://way-cooler.org/docs/wlroots/input/keyboard/event/struct.Key.html">the
event</a>.
The key event has a couple methods but the <a href="http://way-cooler.org/docs/wlroots/input/keyboard/event/struct.Key.html#method.pressed_keys">most important one is
<code>pressed_keys</code></a>.
It will provide all the keys as seen by xkb that were pressed when the event
fired.</p>
<p>You can also see if the key was pressed or not <a href="http://way-cooler.org/docs/wlroots/input/keyboard/event/struct.Key.html#method.key_state">with
<code>key_state</code></a>.
This is necessary to determine the boolean state in <code>KeyboardHandler</code>.</p>
<p>Using the keysyms module from the reexported <a href="https://crates.io/crates/xkbcommon">xkbcommon
crate</a> the list of keys can be iterated over
and pattern matched. Here is all that put together to toggle the booleans
when the appropriate keys are pressed:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl keyboard::Handler for KeyboardHandler {
    fn on_key(&amp;mut self,
              compositor_handle: compositor::Handle,
              _keyboard_handle: keyboard::Handle,
              key_event: &amp;keyboard::event::Key) {
        for key in key_event.pressed_keys() {
            match key {
                keysyms::KEY_Control_L | keysyms::KEY_Control_R =&gt;
                    self.ctrl_pressed = key_event.key_state() == WLR_KEY_PRESSED,
                keysyms::KEY_Shift_L | keysyms::KEY_Shift_R =&gt;
                    self.shift_pressed = key_event.key_state() == WLR_KEY_PRESSED,
                _ =&gt; { /* Do nothing */ }
            }
        }
    }
}
#}</code></pre></pre>
<p>The last piece of the puzzle to stopping the compositor is the <a href="http://way-cooler.org/docs/wlroots/compositor/fn.terminate.html"><code>terminate</code>
function</a>. It
can be called at any time and will gracefully kill clients,
destroy resource managers, and then wind back up the stack to where <code>run</code> was
called.</p>
<p>Here is the complete code for a compositor that will close itself when
<code>Ctrl+Shift+Escape</code> is pressed:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate wlroots;

use wlroots::{compositor,
              input::{self, keyboard},
              utils::log::{WLR_DEBUG, init_logging},
              xkbcommon::xkb::keysyms,
              wlr_key_state::WLR_KEY_PRESSED};

fn main() {
    init_logging(WLR_DEBUG, None);
    let input_builder = input::manager::Builder::default()
        .keyboard_added(keyboard_added);
    compositor::Builder::new()
        .input_manager(input_builder)
        .build_auto(())
        .run()
}

fn keyboard_added(_compositor_handle: compositor::Handle,
                  _keyboard_handle: keyboard::Handle)
                  -&gt; Option&lt;Box&lt;keyboard::Handler&gt;&gt; {
    Some(Box::new(KeyboardHandler::default()))
}

#[derive(Default)]
struct KeyboardHandler {
    shift_pressed: bool,
    ctrl_pressed: bool
}

impl keyboard::Handler for KeyboardHandler {
    fn on_key(&amp;mut self,
              compositor_handle: compositor::Handle,
              _keyboard_handle: keyboard::Handle,
              key_event: &amp;keyboard::event::Key) {
        for key in key_event.pressed_keys() {
            match key {
                keysyms::KEY_Control_L | keysyms::KEY_Control_R =&gt;
                    self.ctrl_pressed = key_event.key_state() == WLR_KEY_PRESSED,
                keysyms::KEY_Shift_L | keysyms::KEY_Shift_R =&gt;
                    self.shift_pressed = key_event.key_state() == WLR_KEY_PRESSED,
                keysyms::KEY_Escape =&gt; {
                    if self.shift_pressed &amp;&amp; self.ctrl_pressed {
                        wlroots::compositor::terminate()
                    }
                },
                _ =&gt; { /* Do nothing */ }
            }
        }
    }
}
</code></pre></pre>
<hr />
<p><sup>1</sup> Huge caveat to this: if the system is deadlocked, such as by an
innocuous <code>loop {}</code>, then the compositor can no longer process input including
the escape sequence. Either test all of your features in a nested instance
(where input can still be processed by the parent system) or have <code>ssh</code> as a
backup to <code>pkill</code> the process.</p>
<a class="header" href="#switching-ttys" id="switching-ttys"><h1>Switching TTYs</h1></a>
<p>Implementing the ability to switch TTYs is not much more difficult <a href="http://way-cooler.org/docs/wlroots/backend/struct.Session.html#method.change_vt">once the
relevant function is located on the <code>Session</code>
struct</a>.
However getting to that struct from the callback requires explaining wlroot-rs
handles.</p>
<blockquote>
<a class="header" href="#handles-in-wlroots-rs" id="handles-in-wlroots-rs"><h1>Handles in wlroots-rs</h1></a>
<p>Handles represent the wlroots-rs solution to the complicated lifetimes of
Wayland resources.</p>
<p>In Rust normally you can either own a value or borrow it for some lifetime.
However, you can't
&quot;own&quot; a keyboard because you don't control its lifetime. At any point, for
example, the keyboard
could be yanked out by the user and then it will need to be cleaned up.</p>
<p>You also can't have these be defined via lifetimes on borrows because
lifetimes behave like a  compile-time read-write lock on data. That does mean,
however, that there can be callbacks that takes a borrow, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Callback for when a key is pressed
fn on_key(keyboard: &amp;Keyboard) {
    // A Keyboard will be valid here because wlroots is single threaded.
}
#}</code></pre></pre>
<p>Unfortunately, now that resource can't escape the callback. Often these
resources will want to be used beyond this limited scope.</p>
<p>To solve this a <code>Handle</code> is used to refer indirectly to resources. Handles are
essentially thin wrappers around
<a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code> smart pointers</a>.
They can only be accessed in
callbacks by calling <code>run</code> on them, which performs additional safety checks to
ensure the <code>Handle</code> is valid.</p>
<p>In order to make using handles easier there are also two macros that make
them much easier to use:
<a href="http://way-cooler.org/docs/wlroots/macro.with_handles.html">with_handles</a>
and <a href="http://way-cooler.org/docs/wlroots_dehandle/macro.wlroots_dehandle.html">wlroots_dehandle</a>.
Either, or neither, can be used. They are only implemented as a convenience.</p>
<p>However, <code>wlroots_dehandle</code> will be used later in this book since it is the
most convenient way to use handles. <a href="http://way-cooler.org/docs/wlroots_dehandle/macro.wlroots_dehandle.html">So please read its
documentation</a>.</p>
<p>Please read <a href="http://way-cooler.org/docs/wlroots/utils/struct.Handle.html">the handle documentation in order to better understand
Handles</a>.</p>
</blockquote>
<a class="header" href="#accessing-the-session-from-the-compositor" id="accessing-the-session-from-the-compositor"><h2>Accessing the Session from the Compositor</h2></a>
<p>A <code>Session</code> is <a href="http://way-cooler.org/docs/wlroots/backend/enum.Backend.html#method.get_session">obtained from a
<code>Backend</code></a>.
A <code>Backend</code> can be <a href="http://way-cooler.org/docs/wlroots/compositor/struct.Compositor.html#method.backend">obtained from a
<code>&amp;Compositor</code></a>.
To get a reference to the <code>Compositor</code> the <code>compositor_handle</code> must be upgraded.</p>
<p>When you upgrade a handle it can potentially fail <a href="http://way-cooler.org/docs/wlroots/utils/struct.Handle.html#method.run">according to its
signature</a>.
The <a href="http://way-cooler.org/docs/wlroots/utils/enum.HandleErr.html">possible error
values</a> indicate
the two requirements for upgrading a handle are:</p>
<ol>
<li>Two handles to the same resource can not be upgraded at the same time. If
this were allowed there could be two mutable references to the same resource
which is against Rust's memory model.</li>
<li>If the resource behind the handle has been destroyed then the handle can
never be upgraded again.<sup>1</sup></li>
</ol>
<p>Because these errors should not occur for the compositor handle, it is
sufficient to simply <code>unwrap</code> the result:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl keyboard::Handler for KeyboardHandler {
    fn on_key(&amp;mut self,
              compositor_handle: compositor::Handle,
              _keyboard_handle: keyboard::Handle,
              key_event: &amp;keyboard::event::Key) {
        for key in key_event.pressed_keys() {
            match key {
                keysyms::KEY_XF86Switch_VT_1 ..= keysyms::KEY_XF86Switch_VT_12 =&gt; {
                    compositor_handle.run(|compositor| {
                        let backend = compositor.backend_mut();
                        if let Some(mut session) = backend.get_session() {
                            session.change_vt(key - keysyms::KEY_XF86Switch_VT_1 + 1);
                        }
                    }).unwrap();
                }
                _ =&gt; { /* Do nothing */ }
            }
        }
    }
}
#}</code></pre></pre>
<hr />
<p><sup>1</sup> In this case the <code>Compositor</code> lives for the life of the compositor,
so it will never be <code>AlreadyDropped</code>. This is not the case for other resources,
such as keyboards.</p>
<a class="header" href="#exercises-1" id="exercises-1"><h1>Exercises</h1></a>
<a class="header" href="#sharing-keyboard-state" id="sharing-keyboard-state"><h2>Sharing keyboard state</h2></a>
<p>Because the ctrl and shift booleans are implemented on the <code>KeyboardHandler</code>
each keyboard gets its own state. That means if you have multiple keyboards
plugged in then the key combination must all be done on the same keyboard.</p>
<p>Modify the compositor to not have this limitation.</p>
<p>Hint: Instead of a global, try replacing the state passed to the
<code>compositor::Builder</code>. The compositor can be
<a href="http://way-cooler.org/docs/wlroots/compositor/struct.Compositor.html#method.downcast">downcasted</a>
to this state.</p>
<a class="header" href="#getting-to-the-point" id="getting-to-the-point"><h1>Getting to the Point</h1></a>
<p>Now that the compositor can be started and stopped successfully, it's about time
that it actually starts doing what it's designed to do: composite some stuff.</p>
<p>There are, generally speaking, two types of resources the compositor will
render: contents of buffers owned by the compositor and contents of buffers
owned by clients.</p>
<p>Client provided buffers are more complicated to handle in general. They must
synchronize their buffers with the compositor so that it can render without
screen tearing. Clients can also damage only part of their buffers to reduce the
amount of redrawing per frame. Because of this complexity, clients will be dealt
with in a later chapter.</p>
<p>Between different compositors the amount of compositor-owned buffers varies.
For example, some compositors render their own background, status bars, and
window decorations whilst others leave all that up to clients. Neither is more
right or wrong than the other, but each leads to certain design trade-offs.</p>
<p>However, at least among desktop compositors, there is at least one
compositor owned object they all generally have to render: the cursor.</p>
<p>As simple as that sounds, it's actually very complicated rendering a cursor
correctly. Thankfully wlroots makes it much easier.</p>
<p><a href="https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html">Suggested reading for an in-depth dive on how input handling works in
wlroots</a>.</p>
<a class="header" href="#a-basic-cursor" id="a-basic-cursor"><h1>A basic cursor</h1></a>
<p>There are two main problems that need to be solved to handle a single cursor on
the screen:<sup>1</sup></p>
<ol>
<li>Keeping track of where the mouse is.</li>
<li>Rendering the mouse where it is.</li>
</ol>
<p>The first problem can be solved with two numbers and an event listener. The
second can be solved with <a href="ftp://www.x.org/pub/X11R7.7/doc/man/man3/Xcursor.3.xhtml">xcursor</a>.</p>
<a class="header" href="#keeping-track-of-the-mouse" id="keeping-track-of-the-mouse"><h2>Keeping track of the mouse</h2></a>
<p>In order to keep track of the mouse a new input device will need to be managed
by the compositor. For this purpose wlroots provides a
<a href="http://way-cooler.org/docs/wlroots/input/pointer/index.html">Pointer</a>. It
abstracts over all types of common mouse input<sup>2</sup>, courtesy of libinput.</p>
<p>Like Keyboard, a Pointer is instantiated using the input builder:</p>
<pre><pre class="playpen"><code class="language-rust">struct PointerHandler;

impl pointer::Handler for PointerHandler {
    // By default, all events are ignored
}

fn pointer_added(_compositor_handle: compositor::Handle,
                 _pointer_handle: pointer::Handle)
                 -&gt; Option&lt;Box&lt;pointer::Handler&gt;&gt; {
    Some(Box::new(PointerHandler))
}


fn main() {
    let input_builder = wlroots::input::manager::Builder::default()
        .pointer_added(pointer_added)
    // Other setup elided...
}
</code></pre></pre>
<p>The event that is emitted when the mouse is moved is <a href="http://way-cooler.org/docs/wlroots/input/pointer/event/struct.Motion.html">the motion
event</a>.
This event is provided in the <a href="http://way-cooler.org/docs/wlroots/input/pointer/trait.Handler.html#method.on_motion"><code>pointer::Handler::on_motion</code>
callback</a>.
This event provides deltas corresponding to the movement amount. By keeping a
running sum, the absolute position of the mouse, in output coordinates, can be
determined.</p>
<blockquote>
<a class="header" href="#different-coordinate-types" id="different-coordinate-types"><h1>Different coordinate types</h1></a>
<p>Throughout this book different coordinate types will be used. Each coordinate
is a number representing a position inside some viewport.</p>
<p>The main types of coordinates used are:</p>
<ol>
<li>Output coordinates</li>
<li>Output layout coordinates</li>
<li>View coordinates</li>
</ol>
<p>They are generally distinguished in the docs and code by prepending a letter
to the variable name. For example <code>lx</code> is the x position in relation to the
output layout.</p>
<p>The origin point will always be in the top left corner.</p>
</blockquote>
<p>The coordinates can be stored in the <code>PointerHandler</code> and updated on each event:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct PointerHandler {
    /// The x coordinate in relation to the output.
    ox: f64,
    /// The y coordinate in relation to the output.
    oy: f64
}

impl pointer::Handler for PointerHandler {
    fn on_motion(&amp;mut self,
                 compositor_handle: compositor::Handle,
                 _pointer_handle: pointer::Handle,
                 motion_event: &amp;pointer::event::Motion) {
        let (delta_x, delta_y) = motion_event.delta();
        self.x += delta_x;
        self.y += delta_y;
    }
}
#}</code></pre></pre>
<a class="header" href="#rendering-a-mouse-with-xcursor" id="rendering-a-mouse-with-xcursor"><h2>Rendering a mouse with xcursor</h2></a>
<p>Now that the mouse position can be tracked it's time to render it to the screen.</p>
<p>The xcursor library doesn't render anything itself, it just provides images from
the system. In a typical desktop environment the cursor changes its icon
depending on what's under it, which requires a manager to keep track of all
these types of images.</p>
<p>In fact, in Wayland clients can dictate what the cursor looks like. When a
client is receiving input from the mouse it can provide its own cursor image.
Though the compositor is not obligated to use this mouse, it is common to do so.</p>
<p>An <a href="http://way-cooler.org/docs/wlroots/cursor/xcursor/struct.Theme.html">xcursor
theme</a> can
be
<a href="http://way-cooler.org/docs/wlroots/cursor/xcursor/struct.Theme.html#method.load_theme">loaded</a>
at the start of the program and stored in the <code>CompositorState</code>.<sup>3</sup></p>
<p>Now that the image has been obtained there needs to be something to render it
onto. Thus far the compositor has not been aware of any outputs, beyond the auto
detection it does during backend setup.</p>
<a class="header" href="#outputs" id="outputs"><h3>Outputs</h3></a>
<p>An <a href="http://way-cooler.org/docs/wlroots/output/struct.Output.html">Output</a>
represents a rectangular view port on which clients and other content are
rendered. Generally this means a monitor plugged into the computer, though if
the Wayland or X11 backends are used then it will instead be a window as a
client to the host system.</p>
<p>Setting up an output is done in the same as setting up an input. There is only
one crucial difference: when setting up an output there needs to be a <a href="http://way-cooler.org/docs/wlroots/output/struct.Builder.html">mode set
for the output using the builder passed into the
function</a>.</p>
<pre><pre class="playpen"><code class="language-rust">struct OutputHandler;

impl output::Handler for OutputHandler {}

    fn output_added&lt;'output&gt;(compositor: compositor::Handle,
                             builder: output::Builder&lt;'output&gt;)
                             -&gt; Option&lt;output::BuilderResult&lt;'output&gt;&gt; {
    Some(builder.build_best_mode(OutputHandler))
}

fn main() {
    let output_builder = wlroots::output::manager::Builder::default()
        .output_added(output_added);
    let compositor = compositor::Builder::new()
        .gles2(true)
        .input_manager(input_builder)
        .output_manager(output_builder)
}
</code></pre></pre>
<p>Rendering is done in the <a href="http://way-cooler.org/docs/wlroots/output/trait.Handler.html#method.on_frame">on frame
callback</a>,
however for cursors this is not necessary. wlroots provides a special <a href="http://way-cooler.org/docs/wlroots/output/struct.Cursor.html">output
cursor</a> which
abstracts over rendering a cursor. This is because many backends support
&quot;hardware&quot; cursors. This is a feature provided by GPUs that allow moving a
cursor around the screen without redrawing anything underneath it.</p>
<p>If hardware cursors aren't supported the <code>output::Cursor</code> will revert to using
software cursors automatically.</p>
<p>Using this new type this is a complete basic cursor implementation with wlroots:</p>
<pre><pre class="playpen"><code class="language-rust">struct OutputHandler;

impl output::Handler for OutputHandler {}

#[wlroots_dehandle]
fn output_added&lt;'output&gt;(compositor: compositor::Handle,
                         builder: output::Builder&lt;'output&gt;)
                         -&gt; Option&lt;output::BuilderResult&lt;'output&gt;&gt; {
    let result = builder.build_best_mode(OutputHandler);
    {
        #[dehandle] let compositor = compositor;
        #[dehandle] let output = &amp;result.output;
        let state: &amp;mut CompositorState = compositor.downcast();
        let mut cursor = output::Cursor::new(output)
            .expect(&quot;Could not create output cursor&quot;);
        let xcursor = state.theme.get_cursor(&quot;left_ptr&quot;.into())
            .expect(&quot;Could not load default cursor set&quot;);
        let image: wlroots::render::Image = xcursor.image(0)
            .expect(&quot;xcursor had no images&quot;).into();
        cursor.set_image(&amp;image)
            .expect(&quot;Could not set cursor image&quot;);
        state.cursor = Some(cursor);
    }
    Some(result)
}

struct PointerHandler;

impl pointer::Handler for PointerHandler {
    #[wlroots_dehandle]
    fn on_motion(&amp;mut self,
                 compositor_handle: compositor::Handle,
                 _pointer_handle: pointer::Handle,
                 motion_event: &amp;pointer::event::Motion) {
        #[dehandle] let compositor = compositor_handle;
        let &amp;mut CompositorState { ref mut cursor, .. } = compositor.downcast();
        if let Some(cursor) = cursor.as_mut() {
            let (delta_x, delta_y) = motion_event.delta();
            let (cur_x, cur_y) = cursor.coords();
            cursor.move_relative(cur_x + delta_x, cur_y + delta_y)
                .expect(&quot;Could not move cursor&quot;);
        }
    }
}


fn pointer_added(_compositor_handle: compositor::Handle,
                 _pointer_handle: pointer::Handle)
                 -&gt; Option&lt;Box&lt;pointer::Handler&gt;&gt; {
    Some(Box::new(PointerHandler))
}

struct CompositorState {
    theme: xcursor::Theme,
    cursor: Option&lt;wlroots::output::Cursor&gt;
}

fn main() {
    init_logging(WLR_DEBUG, None);
    let theme = xcursor::Theme::load_theme(None, 16)
        .expect(&quot;Could not create xcursor manager&quot;);
    let output_builder = wlroots::output::manager::Builder::default()
        .output_added(output_added);
    let input_builder = wlroots::input::manager::Builder::default()
        .pointer_added(pointer_added)
        .keyboard_added(keyboard_added);
    let compositor = compositor::Builder::new()
        .gles2(true)
        .input_manager(input_builder)
        .output_manager(output_builder)
        .build_auto(CompositorState { theme, cursor: None });
    compositor.run();
}
</code></pre></pre>
<blockquote>
<a class="header" href="#box-of-the-socratic-teaching-style" id="box-of-the-socratic-teaching-style"><h1>Box of the Socratic Teaching Style</h1></a>
<p>Before continuing, I suggest you think for a moment on some complications or
desirable features we ignored in this design. Try using the above example
yourself and see if there's any bugs in it.</p>
<p>When considering features for your compositor, it's important to consider
setups different from your own, which can help ensure your compositor is
flexible enough to withstand the &quot;real world&quot;.</p>
</blockquote>
<a class="header" href="#problems-with-this-approach" id="problems-with-this-approach"><h2>Problems with this approach</h2></a>
<p>Unfortunately, this is a very bad solution to the problem. One problem that's
obvious if the above example is tried is that there are no bounds checks for
when the cursor goes outside the output.</p>
<p>Another problem, which is more difficult to solve, is when multiple outputs are
connected. When this happens only the last one gets a cursor and the others are
inaccessible. This is because each output is its own buffer and have no relation
to the others. So a relationship between outputs must be establish where it's
possible to &quot;move&quot; to another output when the edge of another is reached.</p>
<p>Finally, this solution also doesn't address how to react to drawing tablets or
touch screens.</p>
<p>These problems are all very complicated, not to mention very boring. In order to
solve them wlroots provides two semi-connected abstractions: a
<a href="http://way-cooler.org/docs/wlroots/cursor/struct.Cursor.html">Cursor</a> and a
<a href="http://way-cooler.org/docs/wlroots/output/layout/struct.Layout.html">Layout</a>.</p>
<hr />
<p><sup>1</sup> Note that in Wayland there are no restrictions on the number of
cursors. Multiple cursors can be rendered at the same time and can be controlled
by any number of other input devices (including fake ones).</p>
<p><sup>2</sup> Non-exhaustive list: common two/three button mice, multi-button
mice, trackpoints, touchpads, and trackballs.</p>
<p><sup>3</sup> Generally a <a href="http://way-cooler.org/docs/wlroots/cursor/xcursor/struct.Manager.html">theme
manager</a>
is used to generate these themes, but this will be ignored for now.</p>
<a class="header" href="#setting-up-a-cursor-and-an-outputlayout" id="setting-up-a-cursor-and-an-outputlayout"><h1>Setting up a <code>Cursor</code> and an <code>output::Layout</code></h1></a>
<p>A <code>Cursor</code> can be <a href="http://way-cooler.org/docs/wlroots/cursor/struct.Cursor.html#method.create">created at any
time</a>.
Cursors use handles just like all resources provided in wlroots callbacks, so to
use the rest of the methods it must be upgraded.<sup>1</sup></p>
<p>A <code>Cursor</code> can be
<a href="http://way-cooler.org/docs/wlroots/cursor/struct.Cursor.html#method.attach_output_layout">attached</a>
to an <code>output::Layout</code> which will constrain the input to remain within the
region. The layout also keeps track of where the outputs are in relation to each
other, so when the cursor reaches the edge of two outputs it will automatically
warp to the next one.</p>
<p>An <code>output::Layout</code> can be <a href="http://way-cooler.org/docs/wlroots/output/layout/struct.Layout.html#method.create">created just like a
<code>Cursor</code></a>.</p>
<p>Here is the new compositor setup code that uses <code>Cursor</code>, <code>output::Layout</code>, and
<code>xcursor::Manager</code><sup>2</sup>:</p>
<pre><pre class="playpen"><code class="language-rust">pub struct CompositorState {
    xcursor_manager: wlroots::cursor::xcursor::Manager,
    cursor_handle: wlroots::cursor::Handle,
    output_layout_handle: wlroots::output::layout::Handle
}

fn main() {
    init_logging(WLR_DEBUG, None);
    let compositor_state = setup_compositor_state();
    let output_builder = wlroots::output::manager::Builder::default()
        .output_added(output_added);
    let input_builder = wlroots::input::manager::Builder::default()
        .pointer_added(pointer_added)
        .keyboard_added(keyboard_added);
    let compositor = compositor::Builder::new()
        .input_manager(input_builder)
        .output_manager(output_builder)
        .build_auto(compositor_state);
    compositor.run();
}

#[wlroots_dehandle]
pub fn setup_compositor_state() -&gt; CompositorState {
    use wlroots::{cursor::{Cursor, xcursor},
                  output::layout::Layout};
    use crate::{pointer::CursorHandler, output::LayoutHandler};
    let output_layout_handle = Layout::create(Box::new(LayoutHandler));
    let cursor_handle = Cursor::create(Box::new(CursorHandler));
    let xcursor_manager = xcursor::Manager::create(&quot;default&quot;.to_string(), 24)
        .expect(&quot;Could not create xcursor manager&quot;);
    xcursor_manager.load(1.0);
    #[dehandle] let output_layout = output_layout_handle.clone();
    #[dehandle] let cursor = cursor_handle.clone();
    cursor.attach_output_layout(output_layout);
    CompositorState { xcursor_manager,
                      cursor_handle,
                      output_layout_handle }
}
</code></pre></pre>
<a class="header" href="#using-outputlayout" id="using-outputlayout"><h1>Using <code>output::Layout</code></h1></a>
<p>Outputs can be <a href="http://way-cooler.org/docs/wlroots/output/layout/struct.Layout.html#method.add_auto">added to the layout with
<code>Layout::add_auto</code></a>
once they are advertised to the compositor:<sup>3</sup> This will allow the
cursor to warp to the next output when the edge is reached between two outputs
in the output layout coordinate space.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wlroots_dehandle]
pub fn output_added&lt;'output&gt;(compositor: compositor::Handle,
                             builder: output::Builder&lt;'output&gt;)
                             -&gt; Option&lt;output::BuilderResult&lt;'output&gt;&gt; {
    let result = builder.build_best_mode(OutputHandler);
    #[dehandle] let compositor = compositor;
    let CompositorState { ref output_layout_handle, .. } = compositor.downcast();
    #[dehandle] let output = result.output.clone();
    #[dehandle] let output_layout = output_layout_handle;
    output_layout.add_auto(output);
    Some(result)
}
#}</code></pre></pre>
<a class="header" href="#moving-the-pointer" id="moving-the-pointer"><h1>Moving the <code>Pointer</code></h1></a>
<p>There is no longer any need to keep track of the current pointer location. This
is tracked by the <code>Cursor</code> and can be updated using <code>move_relative</code> and <code>warp</code>.</p>
<p>We also should update the cursor image when a pointer is added so that the
correct state can be rendered.</p>
<p>Finally here is the code that updates the cursor when the pointer moves:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct PointerHandler;

impl pointer::Handler for PointerHandler {
    /// Triggered when the pointer is moved on the Wayland and X11 backends.
    #[wlroots_dehandle]
    fn on_motion_absolute(&amp;mut self,
                          compositor_handle: compositor::Handle,
                          _pointer_handle: pointer::Handle,
                          absolute_motion_event: &amp;pointer::event::AbsoluteMotion) {
        #[dehandle] let compositor = compositor_handle;
        let &amp;mut CompositorState { ref cursor_handle, .. } = compositor.downcast();
        #[dehandle] let cursor = cursor_handle;
        let (x, y) = absolute_motion_event.pos();
        cursor.warp_absolute(absolute_motion_event.device(), x, y);
    }

    #[wlroots_dehandle]
    /// Triggered when the pointer is moved in the DRM backend.
    fn on_motion(&amp;mut self,
                 compositor_handle: compositor::Handle,
                 _pointer_handle: pointer::Handle,
                 motion_event: &amp;pointer::event::Motion) {
        #[dehandle] let compositor = compositor_handle;
        let &amp;mut CompositorState { ref cursor_handle, .. } = compositor.downcast();
        #[dehandle] let cursor = cursor_handle;
        let (delta_x, delta_y) = motion_event.delta();
        cursor.move_to(None, delta_x, delta_y);
    }
}

#[wlroots_dehandle]
pub fn pointer_added(compositor_handle: compositor::Handle,
                     pointer_handle: pointer::Handle)
                     -&gt; Option&lt;Box&lt;pointer::Handler&gt;&gt; {
    #[dehandle] let compositor = compositor_handle;
    #[dehandle] let pointer = pointer_handle;
    let CompositorState { ref cursor_handle, ref mut xcursor_manager,
                          .. } = compositor.downcast();
    #[dehandle] let cursor = cursor_handle;
    xcursor_manager.set_cursor_image(&quot;left_ptr&quot;.to_string(), cursor);
    cursor.attach_input_device(pointer.input_device());
    Some(Box::new(PointerHandler) as Box&lt;pointer::Handler&gt;)
}
#}</code></pre></pre>
<hr />
<p><sup>1</sup> Unlike most resources in wlroots, <code>Cursor</code> lifetimes are entirely
dictated by your code. It will hang around until you <a href="http://way-cooler.org/docs/wlroots/cursor/struct.Handle.html#method.destroy">destroy
it</a>.
However, it acts like the other resources for consistency and because their
lifetimes are tied to other resources. There are two other types like this:
<a href="http://way-cooler.org/docs/wlroots/output/layout/struct.Layout.html"><code>output::Layout</code></a>
and <a href="http://way-cooler.org/docs/wlroots/seat/struct.Seat.html"><code>Seat</code></a>.</p>
<p><sup>2</sup> Since the code is getting very long large parts of it will be
elided going forward. The full source can always be found <a href="https://github.com/swaywm/wlroots-rs/tree/master/how-to-make-a-wayland-compositor/src">in the book
repo</a>.</p>
<p><sup>3</sup> Normally you'd want to <a href="http://way-cooler.org/docs/wlroots/output/layout/struct.Layout.html#method.add">add the output at a specific
point</a>
in the layout. However this requires user configuration, which is out of the
scope of this book. Currently there is no xrandr equivalent for Wayland.</p>
<a class="header" href="#exercises-2" id="exercises-2"><h1>Exercises</h1></a>
<a class="header" href="#one-cursor-per-output" id="one-cursor-per-output"><h2>One Cursor Per Output</h2></a>
<p>If you have multiple outputs lets do something a little different.</p>
<p>Instead of storing the <code>cursor::Handle</code> in <code>CompositorState</code> try storing it in
the <code>OutputHandler</code>. This will give each output its own cursor. You should add a
keybinding to switch what the &quot;current&quot; one is.</p>
<a class="header" href="#multiple-input-cursors" id="multiple-input-cursors"><h2>Multiple Input Cursors</h2></a>
<p>If you have multiple input devices hanging around then lets get a little crazy.</p>
<p>Instead of storing the <code>cursor::Handle</code> in <code>CompositorState</code> try storing it in
the <code>PointerHandler</code>. This will allow each pointer to have its own, separate
cursor.</p>
<a class="header" href="#configuring-outputs" id="configuring-outputs"><h2>Configuring Outputs</h2></a>
<p>If you have multiple outputs you probably noticed that the cursor can reach
across all of them. However, it is probably not going across the correct edge
since wlroots has no way to know how the monitors are physically set up in the
world.</p>
<p>Using <a href="http://way-cooler.org/docs/wlroots/output/layout/struct.Layout.html#method.add">the non-auto functions in
<code>output::Layout</code></a>,
and a configuration description of your choice make it possible for the user to
set up their outputs how they like.</p>
<blockquote>
<p>Without endorsing any particular configuration format, it is suggested that
you nevertheless use <a href="https://github.com/serde-rs/serde">serde</a> as that is
the standard way in Rust to encode and decode arbitrary formats.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
